---
title: "Descriptive Statistics"
subtitle: "A Very Brief Introduction/Overview"
institute: "Ethan Marzban (for DS Collab)"
author: "October 12, 2023"
footer: "[dscollab.github.io](https://dscollab.github.io)"
logo: "main_logo2.png"
format: 
  revealjs:
    theme: slides.scss
    multiplex: true
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: true
    html-math-method: mathjax
editor: visual
execute:
  freeze: auto
---

```{r}
#| include: false

# figure options
knitr::opts_chunk$set(
  fig.width = 10, fig.asp = 0.618, out.width = "90%",
  fig.retina = 3, dpi = 300, fig.align = "center"
)
```

## Goals for Today

-   Introduce the [Data Science Lifecycle]{style="color:red"}

-   Discuss the [data matrix]{style="color:red"} representation of [data]{style="color:red"}

-   Introduce the topics of [Descriptive Statistics]{style="color:red"} and [Exploratory Data Analysis]{style="color:red"}

## Quick Disclaimer {style="font-size:35px"}

-   Typically, when I teach these concepts in a course (like PSTAT 5A), I try to emphasize the *background* or *details* of various tools/methods.

    -   I do this to try and foster a greater sense of *intuition*

-   In the interest of time, however, I have tried to keep this workshop fairly brief and have, at times, forgone details in favor of brevity.

-   For those who would like more information, I'll also be uploading a series of Appendices to the website that contain further details and examples on some of the concepts I discuss today.

# Part 0: The Data Science Lifecycle

------------------------------------------------------------------------

![Adapted from https://learningds.org/ch/01/lifecycle_cycle.html](lifecycle5.svg)

------------------------------------------------------------------------

![Adapted from https://learningds.org/ch/01/lifecycle_cycle.html](dsl.svg)

## Understanding Data

-   A key part of the Data Science Lifecycle is to *understand our data*.

-   This entails many different aspects.

-   One part of the process of understanding data is [Exploratory Data Analysis]{style="color:red"} (often abbreviated EDA).

-   We will cover different aspects of EDA over the course of the next few workshops.

# Part 1: Data {background-color="black" background-image="https://media3.giphy.com/media/V4NSR1NG2p0KeJJyr5/giphy.gif?cid=ecf05e470ime1ez5ld7qvaauyw8ml3pt2dt58dqhoko1y2mo&ep=v1_gifs_search&rid=giphy.gif&ct=g" background-size="contain"}

## What is Data?

![](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExMWUyYWRhN2M2ZmI3OGFlZTNhMWI2NDY4NDNjNTc4NjM0MzU5NTRlMyZjdD1n/j6TdvPXdAssootjCKZ/giphy.gif)

## What is Data?

-   According to Merriam-Webster ([source](https://www.merriam-webster.com/dictionary/data)), there are three definitions for [data]{style="color:red"}:

1)  factual information (such as measurements or statistics) used as a basis for reasoning, discussion, or calculation

2)  information in digital form that can be transmitted or processed

3)  information output by a sensing device or organ that includes both useful and irrelevant or redundant information and must be processed to be meaningful

------------------------------------------------------------------------

::: nonincremental
-   I like the first definition, mainly because of the phrase "used as a basis for reasoning, discussion, or calculation."
:::

-   Data, though incredibly useful, is not the be-all and end-all; rather, it should be viewed as a stepping stone for further discussion and/or analysis!

-   As Data Scientists, [data literacy]{style="color:red"} (the ability to think critically about data, and to understand not only what it is saying but also the ways in which it can be manipulated to deceive) is key.

## Example of Data

-   As a concrete example of a dataset, let's explore the so-called `palmerpenguins` dataset.

-   Collected by Dr. Kristen Gorman at the Palmer Station in Antarctica, this dataset contains various measurements of 344 different penguins Dr. Gorman encountered.

------------------------------------------------------------------------

```{r, message = F, echo = F}
#| class-output: hscroll

library(palmerpenguins)
library(tidyverse)
# penguins
cat(format(as_tibble(penguins))[-c(3L, 1L)], sep = "\n")
```

```{css, echo=FALSE}
.hscroll {
  overflow-x: auto;
  white-space: nowrap;
}
```

-   Notice that our data is formatted as a table. This table is what data scientists refer to as the [data matrix.]{style="color:red"}

    -   The data matrix representation for data is one of the most popular ways to display data.

## Terminology {style="font-size:32px"}

-   Each row of the data matrix above corresponds to an individual penguin.

    -   In general, we refer to a given row of the data matrix as an [observational unit]{style="color:red"}, or [case]{style="color:red"}.

-   For each penguin, we can see that there are observations on several different characteristics; species, island, bill length (in mm), bill depth (in mm), flipper length (in mm), body mass (in grams), sex, and year of observation.

    -   Notice that these are the column names in our data matrix above. In general, the columns of the data matrix are referred to as [variables]{style="color:red"}

## Quick Summary

::: callout-important
Each row of the data matrix corresponds to a unique [observational unit]{style="color:red"}, and each column corresponds to a unique [variable]{style="color:red"}
:::

-   Because it is not always obvious what each variable in a given dataset actually represents, most datasets come equipped with a [data dictionary]{style="color:red"}

    -   The data dictionary lists the variables included in the dataset as well as a brief description of each variable.

## Data Dictionary Example

::: {style="font-size:27px"}
|    **Variable**     |                                **Description**                                 |
|:---------------:|:-----------------------------------------------------:|
|      `species`      |          The species of penguin (either Adelie, Chinstrap, or Gentoo)          |
|      `island`       | The island on which the penguin was found (either Biscoe, Dream, or Torgersen) |
|  `bill_length_mm`   |                 The length (millimeters) of the penguin's bill                 |
|   `bill_depth_mm`   |                The depth (in millimeters) of the penguin's bill                |
| `flipper_length_mm` |              The length (in millimeters) of the penguin's flipper              |
|    `body_mass_g`    |                       The mass (in grams) of the penguin                       |
|        `sex`        |                 The sex of the penguin (either Male or Female)                 |
|       `year`        |                   The year in which the penguin was observed                   |
:::

## Leadup

-   If we look at the different variables contained in the `palmerpenguins` dataset, we can see some qualitative differences.

    -   For instance, the observations of `species` are all words/phrases whereas the observations of `bill_length_mm` are numbers.

    -   This leads us to an important remark: there are different kinds of variables! Let's talk about how to classify these different types.

# Part 2: Classifying Variables

## Numerical vs. Categorical {style="font-size:32px"}

-   [Numerical variables]{style="color:red"} are variables whose observations consist of numbers.

    -   Examples: heights, temperatures, number of free throws, etc.

-   Not all variables are numerical. For example, I could take a poll asking people's opinions on the movie *Barbie*- the observations of this variable will most certainly not be numerical.

    -   Rather, the observations of this variable will fall into one of a series of fixed *categories* (e.g. "Enjoyed the movie", "Too much pink", etc.).

    -   As such, we describe non-numerical variables as [categorical variables]{style="color:red"}

## Caution!

-   We actually need to amend our definition of numerical variables slightly.

-   For instance: suppose we have a variable that tracks the months of the year, but encoded using numbers (e.g. `01` for `January`, `02` for `February`, etc.)

-   This is a *categorical* variable, despite the fact that we are using numbers to encode the categories!

    -   For instance, `1` plus `2` is `3`, whereas `January` plus `February` is not `March`

## Caution! {style="font-size:32px"}

::: callout-caution
The categories of a categorical variable may be encoded numerically.
:::

-   This is much more common than you think, largely because computers are better at dealing with numbers than characters!

-   Also, we can modify our definition of numerical variables as follows: a variable is numerical if its values are numbers and it makes interpretive sense to consider adding (or subtracting) two observed values.

## Second Level of Classification

-   There is actually a second level of classification we can make, beyond just `numerical` vs `categorical`.

-   For example, even though both `height` and `number of accidents` are numerical, we know that `height` values can be decimals whereas `number of accidents` must always be an integer.

    -   This leads to the division of numerical variables into [discrete variables]{style="color:red"} and [continuous variables]{style="color:red"}

## Second Level of Classification

-   Analogously, consider `favorite color` and `letter grade`- both variables are categorical, however `letter grades` are clearly *ordered* (`A+` is "better" than `A`, which is "better" than `A-`, etc.) whereas `favorite color` values are not.

    -   This leads to the division of categorical variables into [ordinal variables]{style="color:red"} (i.e. those that have an inherent *ordering*) and [nominal variables]{style="color:red"}.

## Full Classification Scheme

-   I went through that fairly quickly- feel free to ask me any follow-up questions!

::: fragment
```{dot}
//| fig-width: 10
//| fig-height: 4
digraph data_classification {
    layout = dot
    rankdir = UD
    splines = false
    edge [arrowsize = 0.5, color = coral4]
  
subgraph cluster_main {
  color = transparent
  node [color=transparent, style = filled, fillcolor = cornsilk, shape = egg];
  
  Data [label = "Variable"]
  
  subgraph cluster_0 {
   color = transparent
    node [color=transparent, style = filled, fillcolor = aquamarine3, shape = egg];
    
    numerical [label = "Numerical"]
    
    subgraph cluster_1 {
      color = transparent
      node [color = transparent, style = filled, fillcolor = bisque1, shape = egg];
      
        continuous [label = "Continuous"]
        discrete [label = "Discrete"]
    }
    
    {numerical} -> continuous
    {numerical} -> discrete
  }
  
  subgraph cluster_2 {
   color = transparent
    node [color=transparent, style = filled, fillcolor = aquamarine3, shape = egg];
    
    categorical [label = "Categorical"]
    
    subgraph cluster_3 {
      color = transparent
      node [color = transparent, style = filled, fillcolor = bisque1, shape = egg];
      
        nominal [label = "Nominal"]
        ordinal [label = "Ordinal"]
    }
    
    {categorical} -> nominal
    {categorical} -> ordinal
  }
  
  
  }
  
  {Data} -> numerical
  {Data} -> categorical
}
```
:::

# Part 3: Introduction to Descriptive Statistics

## Categorical Variables

-   Consider observations on a single categorical variable (e.g. `species`), $\{x_i\}_{i=1}^{n}$.

-   Our observations $x_i$ necessarily come from a set of $k$ fixed categories (e.g. {`Adelie`, `Chinstrap`, `Gentoo`})

-   How might we produce a visual summary of our observations?

## Bargraph

::: callout
When summarizing observations on a categorical variable, use a [barplot]{style="color:red"} (aka a [bargraph]{style="color:red"})
:::

-   A barplot consists of $k$ bars (one for each category), with the heights of the bars proportional to the frequency of occurence for each category.

    -   I.e. the height of bar 1 is proportional to the number of observations that fall into category 1, the height of bar 2 is proportional to the number of observations that fall into category 2, etc.

## Example: Penguins

-   As a concrete example, here is the `species` variable from the `palmerpenguins` dataset:

::: fragment
```{r, message = F, echo = F}
#| class-output: hscroll

library(palmerpenguins)
penguins$species
```

```{css, echo=FALSE}
.hscroll {
  overflow-x: auto;
  white-space: nowrap;
}
```
:::

------------------------------------------------------------------------

::: nonincremental
-   We see there are three distinct species present in the dataset: Adelie, Chinstrap, and Gentoo.
:::

-   Using a computing software, finding the counts within each category is relatively easy.

```{css echo=FALSE}
.big-code{
  font-size: 150%  
}
```

<div class="big-code">

::: fragment
```{r, message = F, echo = F}
table(penguins$species)
```

</div>
:::

-   So, our bargraph will have 3 bars (one for each of the 3 species), with heights proportional to 152, 68, and 124 respectively.

------------------------------------------------------------------------

```{r, message = F}
library(tidyverse)
library(ggthemes)

data.frame(table(penguins$species)) %>%
  rename(species = Var1, freq = Freq) %>%
  ggplot(aes(x = species, y = freq)) +
  geom_bar(stat = "identity",
           fill = "#7f9ab5") +
  theme_economist_white(base_size = 18) +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.x = element_text(size = 16,
                                    margin = margin(
                                      t = 20, 
                                      r = 0,
                                      b = 0, 
                                      l = 0)),
        axis.title.y = element_text(size = 16),
        title = element_text(size = 18)
  ) +
  ggtitle("Barplot of Species")
```

------------------------------------------------------------------------

## Let's Hear From the Audience! {style="font-size:28px"}

::: nonincremental
-   Given observations of 120 different PSTAT students' favorite color (summarized below), pproximately what proportion of the students in the sample reported either blue or gold as their favorite color?

```{r}
#| echo: false
#| fig-height: 3

set.seed(123)
cols <- sample(c("red", "blue", "green", "orange", "purple", "gold", "other"), 120, replace = T, prob = c(0.15, 0.15, 0.13, 0.14, 0.16, 0.13, 0.14))
cols <- factor(cols,
               levels = c("red", "blue", "green", "orange", "purple", "gold", "other"),
                         ordered = T)

data.frame(table(cols)) %>%
  ggplot(aes(x = cols, y = Freq)) +
  geom_bar(stat = "identity",
           fill = "#7f9ab5") +
  theme_economist_white(base_size = 18) +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.x = element_text(size = 16,
                                    margin = margin(
                                      t = 20, 
                                      r = 0,
                                      b = 0, 
                                      l = 0)),
        axis.title.y = element_text(size = 16),
        title = element_text(size = 18)
  ) +
  ggtitle("Barplot of Colors") +
  ylab("freq")
```
:::

## Numerical Variables {style="font-size:35px"}

-   Suppose now we have $n$ observations $\{x_i\}_{i=1}^{n}$ of a numerical variable.

-   How might we generate a summarizing plot for these observations?

-   First note that we no longer have the notion of "categories", as we did with categorical variables.

    -   For example, consider the `bill_length_mm` variable from the `palmerpenguins` dataset- it is extremely unlikely that there will be two observations that are both exactly equal to any particular value

## Discretization {style="font-size:34px"}

-   We can, however, *inject* some categories into our observations.

-   For example, instead of asking how many penguins have bill lengths of *exactly* 33mm, we can ask how many penguins have bill lengths *between* 30mm and 35mm.

-   That is, our idea is to now consider *intervals* of values, and ask how many observations fall within each interval.

-   These intervals are often referred to as [bins]{style="color:red"}, and the width of each interval is called the [binwidth]{style="color:red"}.

    -   The act of dividing our observations into these bins is called [binning]{style="color:red"}, or [discretization]{style="color:red"}.

## Distribution Table {style="font-size:35px"}

-   The resulting table of counts (i.e. counts within each bin) is called a [distribution table]{style="color:red"}.

-   For example, the distribution table of the `bill_length_mm` variable from the `palmerpenguins` dataset is, using a binwidth of 5mm,

```{css echo=FALSE}
.big-code-2{
  font-size: 130%  
}
```

::: big-code-2
::: fragment
```{r}
bins <- c("[30, 35]", "(35, 40]", "(40, 45]", "(45, 50]", "(50, 55]", "(55, 60]")
bill_length_mm <- na.omit(penguins$bill_length_mm)
counts <- hist(bill_length_mm, plot = F, breaks = 8)$counts

names(counts) <- bins
counts
```
:::
:::

-   Note the use of interval notation; if a datapoint falls on the boundary of a bin, we conventionally assign it to the left (lower) bin.

## Histogram

-   We now use our distribution table in the same way we used our frequency table from before! I.e. we will draw as many rectangles as there are bins, and have the height of each rectangle proportional to the corresponding frequency in the distribution table.

-   This type of plot is called a [histogram]{style="color:red"}.

## Histogram

```{r}
#| echo: false

penguins %>%
  ggplot(aes(x = bill_length_mm)) +
  geom_histogram(col = "white",
                 fill = "#7f9ab5",
                 breaks = seq(30, 60, by = 5)) +
  theme_economist_white(base_size = 18) +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.y = element_text(size = 16,
                                    margin = margin(
                                      t = 0, 
                                      r = 10,
                                      b = 0, 
                                      l = 0)),
        axis.title.x = element_text(size = 16),
        title = element_text(size = 24)
  ) +
  ggtitle("Distribution of Bill Lengths")

```

## Caution: The Importance of Binwidth {style="font-size:35px"}

-   Notice that our notion of a histogram is intimately tied with our choice of binwidth.

-   Different binwidths can produce wildly different histograms!

-   Here is a <a href = "https://epm927.shinyapps.io/Histogram_Binwidths/" target = "_blank">demo</a>

-   In practice, it is a good idea to play around with different binwidths to find one that results in a histogram that displays a moderate amount of detail without becoming so detailed as to lose sight of the bigger picture.

## Boxplots {style="font-size:35"}

-   It turns out there is another way to summarize numerical data visually: using what is known as a [boxplot]{style="color:red"}.

-   Boxplots can be a seem a bit peculiar at first, so let's take a look at one together. Before diving back into the `palmerpenguins` dataset, let's look at a slightly different dataset.

    -   This dataset contains only one variable, which records the scores (out of 100 points) of 140 different students on a final exam.

------------------------------------------------------------------------

```{r, message = F, echo = F}
#| class-output: hscroll

set.seed(130)
x <- rnorm(140, 80, 5)
x <- round(x, 3)
x
```

```{css, echo=FALSE}
.hscroll {
  overflow-x: auto;
  white-space: nowrap;
}
```

------------------------------------------------------------------------

::: nonincremental
-   Here is a histogram of these scores...
:::

```{r}
data.frame(x) %>%
  ggplot(aes(x = x)) +
  geom_histogram(col = "white", bins = 15,
                 fill = "#7f9ab5") +
  theme_economist_white(base_size = 18) +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.y = element_text(size = 16,
                                    margin = margin(
                                      t = 0, 
                                      r = 10,
                                      b = 0, 
                                      l = 0)),
        axis.title.x = element_text(size = 16),
        title = element_text(size = 24)
  ) +
  ggtitle("Histogram of Scores")
```

------------------------------------------------------------------------

::: nonincremental
-   ... and here is a boxplot
:::

```{r}
data.frame(x) %>%
  ggplot(aes(x = x)) +
  stat_boxplot(geom = "errorbar", 
               width = 0.25,
               linewidth = 1) +
  geom_boxplot(fill =  "#7f9ab5", 
               size = 1,
               outlier.size = 4) +
  theme_economist_white(base_size = 18) +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.y = element_text(size = 16,
                                    margin = margin(
                                      t = 0, 
                                      r = 10,
                                      b = 0, 
                                      l = 0)),
        axis.title.x = element_text(size = 16),
        axis.text.y = element_blank(),
        title = element_text(size = 18)
  ) +
  ylim(c(-0.75, 0.75)) +
  ggtitle("Boxplot of Scores")
```

## Anatomy of a Boxplot

\

![](boxplot.svg)

## Understanding Boxplots

-   Let's discuss each of the quantities represented on the boxplot separately.

-   The [first quartile]{style="color:red"} is the value $Q_1$ such that 25% of observations lie to the left of $Q_1$.

-   The [third quartile]{style="color:red"} is the value $Q_3$ such that 75% of observations lie to the left of $Q_3$.

-   The [second quartile]{style="color:red"} is the value $Q_2$ such that 50% of observations lie to the left of $Q_2$. This is often called the [median]{style="color:red"}

## Whiskers

-   Finally, we discuss the role of the whiskers on the boxplot.

-   There are several different conventions for how far the whiskers extend. In some conventions, the whiskers extend to the minimum and maximum values of the data.

-   The convention often used is the following: **the whiskers will never reach farther than** $1.5 \times (Q_3 - Q_1)$.

------------------------------------------------------------------------

-   What this means is that there may be points in our dataset that lie beyond the reach of the whiskers. These points are what we call [outliers]{style="color:red"}.

-   The rationale for constructing the whiskers in this way is to try and highlight any points that are unusually distant from the rest of the data.

------------------------------------------------------------------------

::: fragment
```{r, fig.width = 8, fig.height = 3}
data.frame(x) %>%
  ggplot(aes(x = x)) +
  stat_boxplot(geom = "errorbar", 
               width = 0.25,
               linewidth = 1) +
  geom_boxplot(fill =  "#7f9ab5", 
               size = 1,
               outlier.size = 4) +
  theme_economist_white(base_size = 18) +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.y = element_text(size = 16,
                                    margin = margin(
                                      t = 0, 
                                      r = 10,
                                      b = 0, 
                                      l = 0)),
        axis.title.x = element_text(size = 16),
        axis.text.y = element_blank()
  ) +
  ylim(c(-0.75, 0.75)) +
  ggtitle("Boxplot of Scores") +
  xlab("score")
```
:::

## Quick Summary

-   To summarize observations of a single categorical variable, use bargraphs/barplots.

-   To summarize observations of a single numerical variable, use either histograms or boxplots.

# Part 3.5: Visualizing the Relationship between Multiple Variables

## Leadup

-   So, this takes care of how to summarize a *single* variable.

-   But, as we saw with the `palmerpenguins` dataset, it is entirely plausible to have a dataset that contains *multiple* variables and to want to visualize the *relationship* between some of these variables.

-   Perhaps unsurprisingly, visualizing the relationship between 3 or more variables can be a bit tricky.

-   As such, we will restrict ourselves to comparing only two variables.

## Three Cases

-   Even if we compare only two variables, three cases arise:

    -   Comparing two numerical variables
    -   Comparing one numerical and one categorical variable
    -   Comparing two categorical variables

-   We'll discuss the first two; time-permitting, we'll discuss the third.

## Two Numerical Variables {style="font-size:35px"}

-   Let's say we have two variables, and we want to visualize their relationship.

-   As an example, let's return to the `palmerpenguins` dataset and compare the `bill_length_mm` and `bill_depth_mm` variables. Let's also restrict ourselves to Gentoo penguins.

::: fragment
```{r, message = F, echo = F}
#| class-output: hscroll

library(palmerpenguins)
library(tibble)

# cat(format(as_tibble(mtcars))[-3L], sep = "\n")
gentoo <- penguins %>% filter(species == "Gentoo")

cat(format(as_tibble(gentoo[,3:4]))[-c(3L, 1L)], sep = "\n")
```

```{css, echo=FALSE}
.hscroll {
  overflow-x: auto;
  white-space: nowrap;
}
```
:::

------------------------------------------------------------------------

::: {.fragment style="font-size:35px"}
::: columns
::: {.column width="40%"}
::: nonincremental
-   Notice that each observational unit of this data matrix (consisting only of the `bill_length_mm` and `bill_depth_mm` variables) is a pair of numbers.
:::

-   It is fairly natural, then, to imagine plotting these pair of numbers on a Cartesian coordinate system.
:::

::: {.column width="60%"}
\
\

::: fragment
```{r, fig.height = 7}
library(tidyverse)

penguins %>% filter(species == "Gentoo") %>%
  ggplot(aes(x = bill_length_mm, y = bill_depth_mm)) +
  geom_point(size = 3) +
  theme_economist_white(base_size = 24) +
  ggtitle("Bill Depth vs. Length in Gentoo Penguins") +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.y = element_text(size = 16,
                                    margin = margin(
                                      t = 0, 
                                      r = 10,
                                      b = 0, 
                                      l = 0)),
        axis.title.x = element_text(size = 16,
                                    margin = margin(
                                      t = 10, 
                                      r = 0,
                                      b = 0, 
                                      l = 0)),
        title = element_text(size = 18)
  )
```
:::
:::
:::
:::

## Scatterplot

-   This type of visualization is called a [scatterplot]{style="color:red"}.

-   Specifically, when comparing two numerical variables of the same length, we generate a scatterplot by plotting each observational unit on a Cartesian coordinate system where the axes are prescribed by the variables in question.

::: fragment
::: callout-note
## **Result**

When comparing two numerical variables (of the same length), a scatterplot is the best visualization tool.
:::
:::

## Interpreting Scatterplots {style="font-size:32px"}

::: columns
::: {.column width="70%"}
::: nonincremental
-   Let's return to the scatterplot we generated before:
:::

```{r, fig.height = 7}
library(tidyverse)

gentoo %>%
  ggplot(aes(x = bill_length_mm, y = bill_depth_mm)) +
  geom_point(size = 3) +
  theme_economist_white(base_size = 24) +
  ggtitle("Bill Depth vs. Length in Gentoo Penguins") +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.y = element_text(size = 16,
                                    margin = margin(
                                      t = 0, 
                                      r = 10,
                                      b = 0, 
                                      l = 0)),
        axis.title.x = element_text(size = 16,
                                    margin = margin(
                                      t = 10, 
                                      r = 0,
                                      b = 0, 
                                      l = 0)),
        title = element_text(size = 18)
  )
```
:::

::: {.column width="30%"}
-   Notice how as the values of `bill_length_mm` increase, the corresponding values of `bill_depth_mm` also increase on average?

    -   This makes intutive sense: longer bills are probably deeper!
:::
:::

## Trend {style="font-size:30px"}

-   This is an example of what we call a [trend]{style="color:red"}; specifically, a [positive linear trend]{style="color:red"}

-   Trends can be either [positive]{style="color:red"} or a [negative]{style="color:red"}, and either [linear]{style="color:red"} or [nonlinear]{style="color:red"}.

    -   "Positive" means a one-unit increase in `x` translates to an increase in `y`
    -   "Negative" means a one-unit increase in `x` translates to an degrease in `y`
    -   "Linear" means the rate of change is fixed (i.e. constant)
    -   "Nonlinear" means the rate of change depends on `x`

------------------------------------------------------------------------

::: {.fragment style="font-size:28px"}
::: columns
::: {.column width="50%"}
-   Linear **Negative** Trend:

::: fragment
```{r}
set.seed(123)
x <- rnorm(100)
y <- -2 * x + rnorm(100, 0, 2)

data.frame(x, y) %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(size = 4) +
  theme_economist_white(base_size = 24) +
  ggtitle("Y vs. X") +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.y = element_text(size = 16,
                                    margin = margin(
                                      t = 0, 
                                      r = 10,
                                      b = 0, 
                                      l = 0)),
        axis.title.x = element_text(size = 16,
                                    margin = margin(
                                      t = 10, 
                                      r = 0,
                                      b = 0, 
                                      l = 0)),
        title = element_text(size = 18)
  )
```
:::
:::

::: {.column width="50%"}
-   Nonlinear **Negative** Trend:

::: fragment
```{r}
set.seed(123)
x <- rchisq(100, 20)
y <- (1 / x^2) + rnorm(100, 0, 0.0005)

data.frame(x, y) %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(size = 4) +
  theme_economist_white(base_size = 24) +
  ggtitle("Y vs. X") +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.y = element_text(size = 16,
                                    margin = margin(
                                      t = 0, 
                                      r = 10,
                                      b = 0, 
                                      l = 0)),
        axis.title.x = element_text(size = 16,
                                    margin = margin(
                                      t = 10, 
                                      r = 0,
                                      b = 0, 
                                      l = 0)),
        title = element_text(size = 18)
  )
```
:::
:::
:::

::: columns
::: {.column width="50%"}
-   Linear **Positive** Trend:

::: fragment
```{r}
set.seed(123)
x <- rnorm(100)
y <- 2 * x + rnorm(100, 0, 2)

data.frame(x, y) %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(size = 4) +
  theme_economist_white(base_size = 24) +
  ggtitle("Y vs. X") +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.y = element_text(size = 16,
                                    margin = margin(
                                      t = 0, 
                                      r = 10,
                                      b = 0, 
                                      l = 0)),
        axis.title.x = element_text(size = 16,
                                    margin = margin(
                                      t = 10, 
                                      r = 0,
                                      b = 0, 
                                      l = 0)),
        title = element_text(size = 18)
  )
```
:::
:::

::: {.column width="50%"}
-   Nonlinear **Positive** Trend:

::: fragment
```{r}
set.seed(123)
x <- rchisq(100, 20)
y <- 1 - (1/x^2)  + rnorm(100, 0, 0.0007)

data.frame(x, y) %>%
  ggplot(aes(x = x, y = y)) +
  geom_point(size = 4) +
  theme_economist_white(base_size = 24) +
  ggtitle("Y vs. X") +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.y = element_text(size = 16,
                                    margin = margin(
                                      t = 0, 
                                      r = 10,
                                      b = 0, 
                                      l = 0)),
        axis.title.x = element_text(size = 16,
                                    margin = margin(
                                      t = 10, 
                                      r = 0,
                                      b = 0, 
                                      l = 0)),
        title = element_text(size = 18)
  )
```
:::
:::
:::
:::

## Associations

-   By the way- another way to talk about trends is to phrase things in terms of the variables being compared.

    -   For example, if the scatterplot of two variables displays a positive linear trend, we might say that the two variables have a positive linear [association]{style="color:red"}.

    -   For example, bill length and bill depth appear to have a positive linear association, as seen in the scatterplot from a few slides ago.

## A Numerical and a Categorical Variable {style="font-size:30px"}

-   The final case we will consider today is comparing a numerical variable to a categorical one.

-   As a concrete example, here is a (mock) dataset comprised of the following variables:

::: fragment
| **Variable Name** |                                      **Description**                                      |
|:--------------:|:------------------------------------------------------:|
|    `stdy_hrs`     | average amount of time (in hrs) a student spent studying for a particular class each week |
|     `ltr_grd`     |     the final letter grade (`A+`, `A`, `A-`, etc.) the student received in the class      |
:::

------------------------------------------------------------------------

```{r}
dat <- read.csv("grade_data.csv", header = T)
dat
```

::: {style="font-size:30px"}
-   Note that `ltr_grd` is categorical (in fact, it is ordinal) and `stdy_hrs` is numerical (specifically, continuous).

-   Now, even though the observational units of our data matrix are pairs of quantities, they are no longer pairs of *numbers* and it therefore no longer makes sense to plot them as points on a Cartesian coordinate system.
:::

------------------------------------------------------------------------

::: {style="font-size:32px"}
::: nonincremental
-   The way we get around this is, perhaps surprisingly... boxplots!
:::

::: fragment
```{r}

dat %>%
  ggplot(aes(x = ltr_grd, y = stdy_hrs)) +
  stat_boxplot(geom = "errorbar", 
               width = 0.25,
               linewidth = 1) +
  geom_boxplot(fill =  "#7f9ab5", 
               size = 1,
               outlier.size = 4) +
  theme_economist_white(base_size = 18) +
  ggtitle("Weekly Study Hrs vs. Letter Grade") +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.y = element_text(size = 16,
                                    margin = margin(
                                      t = 0, 
                                      r = 10,
                                      b = 0, 
                                      l = 0)),
        axis.title.x = element_text(size = 16,
                                    margin = margin(
                                      t = 10, 
                                      r = 0,
                                      b = 0, 
                                      l = 0)),
        title = element_text(size = 18,
                                    margin = margin(
                                      t = 0, 
                                      r = 0,
                                      b = 10, 
                                      l = 0))
  ) 
```
:::
:::

## Side-by-Side Boxplots {style="font-size:32px"}

-   This type of plot is called a [side-by-side boxplot]{style="color:red"}.

::: fragment
::: callout-note
## **Result**

::: {style="font-size: 30px"}
When comparing one numerical and one categorical variable, it is best to visualize their relationship using a side-by-side boxplot.
:::
:::
:::

-   Though the notion of trend is slightly different in the context of a side-by-side boxplot, we can still use them to determine relationships.

-   For example, from the plot on the previous slide, we can see that, on average, students who received lower grades tended to study less than those students who received higher grades.

## Trends in Side-by-Side Boxplots

-   Though the notion of trend is slightly different in the context of a side-by-side boxplot, we can still use them to determine relationships.

-   For example, from the plot on the previous slide, we can see that, on average, students who received lower grades tended to study less than those students who received higher grades.

## Causality {style="font-size:35px"}

-   I should make a very important point: identifying trends is not the same thing as identifying [causal relationships]{style="color:red"}.

-   For example, the side-by-side boxplot from a few slides ago does not tell us that "studying less causes your grade to decrease"

    -   There are a lot of other [confounding variables]{style="color:red"} that could contribute to the decrease in grade.

-   We won't talk too much about causality right now, but it is an important thing to be aware of: association is not the same thing as causation!

## Quick Summary

-   To summarize a single variable, use:
    -   a barplot/bargraph if the variable is categorical
    -   a boxplot or a histogram if the variable is numerical
-   To summarize the relationship between two variables, use:
    -   a scatterplot if both variables are numerical
    -   a side-by-side boxplot if one variable is numerical and the other is categorical

## Line Plots

-   Suppose we have a set of observations on a variable `x`, and for each distinct value of `x` there is only one corresponding value `y`.

    -   This often arises when `x` is time; for example, the population of a city at any given point in time is only a single value.

-   In such a case, we *could* generate a scatterplot of `y` vs `x`.

## Example: Population

```{r}
#| echo: False
set.seed(27)

t <- 2010:2023
pop <- (t + rnorm(14, 0, 1)) / 10

data.frame(t, pop) %>%
  ggplot(aes(x = t, y = pop)) + 
  geom_point(size = 5) +
  theme_economist_white(base_size = 16) +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.x = element_text(size = 16,
                                    margin = margin(
                                      t = 20, 
                                      r = 0,
                                      b = 0, 
                                      l = 0)),
        axis.title.y = element_text(size = 16),
        title = element_text(size = 24)
  ) +
  xlab("year") +
  ylab("population (in thousands)") +
  ggtitle("Population over Time")
```

## Line Plots

-   It is sometimes conventional to connect the points on such a graph with straight lines, to generate a [line plot]{style="color:red"}:

## Line Plots

```{r}
#| echo: False
set.seed(27)

t <- 2010:2023
pop <- (t + rnorm(14, 0, 1)) / 10

data.frame(t, pop) %>%
  ggplot(aes(x = t, y = pop)) + 
  geom_point(size = 5) +
  geom_line() +
  theme_economist_white(base_size = 16) +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.x = element_text(size = 16,
                                    margin = margin(
                                      t = 20, 
                                      r = 0,
                                      b = 0, 
                                      l = 0)),
        axis.title.y = element_text(size = 16),
        title = element_text(size = 24)
  ) +
  xlab("year") +
  ylab("population (in thousands)") +
  ggtitle("Population over Time")
```

# Part 4: Numerical Summaries

## Leadup

-   Suppose we have a set of observations $\{x_i\}_{i=1}^{n}$ of a single numerical variable $X$.

    -   Remember that observations of a single variable are just lists of numbers!

-   We have previously seen how to construct a visual summary of $\{x_i\}_{i=1}^{n}$ through either a histogram or a boxplot.

-   We can also provide *numerical* summaries of $\{x_i\}_{i=1}^{n}$ as well.

## Measures of Central Tendency

-   One thing we can do is to describe the "center" of the list $\{x_i\}_{i=1}^{n}$.

    -   Quantites that describe the center of a list of numbers are often referred to as [Measures of Central Tendency]{style="color:red"}

-   One widely used measure of central tendency is the [arithmetic mean]{style="color:red"} $$ \overline{x} = \frac{1}{n} \sum_{i=1}^{n} x_i $$

## Interpretation of the Mean {style="font-size:32px"}

-   If you're curious, there is actually a very nice geometric interpretation of the arithmetic mean.

-   If we were to "plot" our numbers $\{x_i\}_{i=1}^{n}$ on a number line by placing a marble of equal weight at each of the values $x_1, \cdots, x_n$, then the arithmetic mean is actually the point at which a fulcrum can be placed to ensure the entire system remains balanced:

::: fragment
![](mean.svg){width="65%" fig-align="center"}
:::

## The Median

-   Another measure of central tendency is the [median]{style="color:red"}, which, as previously stated, divides the list of numbers $\{x_i\}_{i=1}^{n}$ in half.

-   More concretely, here is the procedure to find the median of a set of numbers:

## The Median

1)  Line up the numbers in ascending order
2)  Cross off the first and last numbers
3)  Cross off the first and last numbers that haven't yet been crossed
4)  Continue until either there is only a single number left uncrossed (in which case this number is the median), or there are two numbers left uncrossed (in which case the mean of these two numbers is the median).

## Mean vs. Median

-   One thing to note is that the median is more [robust]{style="color:red"} than the mean.

-   What this means, loosely speaking, is that it is less affected by outliers.

-   For a bit more understanding of what this means, I refer you to the Appendices I will post later.

## Measures of Spread

-   Sometimes, it may be useful to try and describe how "spread out" a list of numbers is.

-   There are several different metrics used as measures of spread.

-   One is the [range]{style="color:red"}, which is simply computed as the largest number minus the smallest number: $$ \mathrm{range}\left(\{x_i\}_{i=1}^{n}\right) = \max_{1 \leq i \leq n} \{x_i\} - \min_{1 \leq i \leq n} \{x_i\} $$

## The Variance

-   Another often-used measure of spread is the [variance]{style="color:red"}, which is computed using the formula \begin{align*}
    s_X^2     & = \frac{1}{n - 1} \sum_{i=1}^{n} (x_i - \overline{x})^2     \\
              & = \left(\frac{1}{n - 1} \sum_{i=1}^{n} x_i^2 \right) - \frac{n}{n - 1} \cdot (\overline{x})^2 
    \end{align*}

## Interpretation of The Variance

-   The variance can be interpreted as a sort of *average distance of points to the mean*

::: fragment
![](sd.svg){width="65%" fig-align="center"}
:::

## Standard Deviation

-   Note, though, that the units of variance are necessarily the square of the original units of measurements.

    -   For example, if $\{x_i\}_{i=1}^{n}$ represents a series of measurements made in inches, then the units of the variance $s_X^2$ are squared-inches.

-   This can make interpreting the variance a little tricky in some cases.

## Standard Deviation

-   As such, data scientists and statisticians often take the square root of variance to obtain the [standard deviation]{style="color:red"}: $$ s_X = \sqrt{s_X^2} $$

    -   Note, though, that *mathematically* both the variance and the standard deviation provide the same information.

## Standard Deviation

-   Finally, another popular measure of spread is the [Interquartile Range]{style="color:red"} (or IQR for short), defined to be the third quartile minus the first quartile: $$ \mathrm{IQR} = Q_3 - Q_1 $$

-   The IQR is a more robust description of spread than variance.

# Part 5: A Trip To the Movies! {background-color="black" background-image="https://media3.giphy.com/media/pVBUBqNdTdsVuiybM4/giphy.gif?cid=ecf05e47mbv0c1vvwta3exbx78jgi6hz84rjh72zudnxyw6k&ep=v1_gifs_search&rid=giphy.gif&ct=g" background-size="contain"}

## Leadup

::: callout-tip
## Question

Have movies gotten longer or shorter over the years?
:::

-   This is a question I found myself curious about.

    -   As a teen, I remember movies being consistently around 90-ish minutes in length whereas nowadays I see movies being around 120-ish minutes in length.

-   As indicated by the Data Science Lifecycle, the next step is to procure data!

## The Data

-   The Internet Movie Database (IMDb) provides a great repository of data on pieces of film media.

-   This data can be accessed at [this](https://developer.imdb.com/non-commercial-datasets/) link, if you're curious.

-   For this particular mini-project, we will only need a subset of this dataset.

-   In fact, to make things even easier on ourselves, we will restrict our consideration only to films released since the start of the millennium.

## The Data

```{r, message = F, echo = F}
#| class-output: hscroll

movies <- read.csv("movies.csv")
dataset_size <- nrow(movies)
head(movies, 100)
```

```{css, echo=FALSE}
.hscroll {
  overflow-x: auto;
  white-space: nowrap;
}
```

-   `r dataset_size` observational units included in the data matrix

## Results

-   With a bit of work, we can compute the average (mean) runtime of films released every year since 2000 and use this to generate a line plot.

    -   I'll be going over the code to do this in a future workshop.

------------------------------------------------------------------------

```{r, echo = F}
library(tidyverse)
library(ggthemes)

movies <- read.csv("movies.csv")

# remove movies with lengths greater than 300 minutes
movies_cleaned <- movies[-which(movies$runtime > 300),]
movies_cleaned <- na.omit(movies_cleaned)

# compute the average runtimes per year
group_means <- movies_cleaned %>%
  group_by(year) %>%
  summarise(x = mean(runtime))

# generate the plot
data.frame(x = 2000:2023) %>%
  ggplot(aes(x = x)) +
  geom_point(aes(x = x, y = group_means$x), size = 5) +
  geom_line(aes(x = x, y = group_means$x)) +
  theme_economist_white(base_size = 16) +
  theme(panel.background = element_rect("white"),
        plot.background = element_rect(fill = "white"),
        axis.title.x = element_text(size = 16,
                                    margin = margin(
                                      t = 20, 
                                      r = 0,
                                      b = 0, 
                                      l = 0)),
        axis.title.y = element_text(size = 16),
        title = element_text(size = 24)
  ) +
  xlab("year of release") +
  ylab("average runtime (mins)") +
  ggtitle("Average Runtime vs. Year")
```

## Discussing the Plot

-   Notice that, based on the plot alone, we have a pretty good idea of how to answer our original question!

-   Of course, we could provide a more statistical answer using things like Hypothesis Testing (to formally *test* whether the average runtime of films has changed over years).

-   But, for now, I hope you see how the act of simply generating an appropriate visualization can be incredibly illuminating!

# Part 6: Good Graphics vs. Bad Graphics

## Leadup

-   I would be remiss if I were to not impart to you some tips and tricks for making good visualizations.

-   Let's start off by roasting some bad ones.

-   For each of the following graphs, let's discuss some things that could be improved upon!

-   *Source:* Many of these plots come from https://www.businessinsider.com/the-27-worst-charts-of-all-time-2013-6

## Graph 1

![](badvis/pie.webp){width="50%"}

## Graph 2

![](badvis/allzero.png){width="75%"}

## Graph 3

![](badvis/ucsb_bargraph.png){width="75%"}

## Graph 4

![](badvis/fast_food_area.png){width="75%"}

## Scale

-   Speaking of scale, make keep in mind the dangers of rescaling plots!

## Plot; Scale 1

```{r}
source("badvis/code/plots.R")

p1
```

## Plot; Scale 2

```{r}
p2
```

## Plot; Scale 3

```{r}
p3
```

## Colorblind Accessibility

-   Finally, I should also mention that there are certain steps we can (and should) take to make our plots more colorblind-accessible.

-   One piece of advice many people suggest is to avoid using complex background visuals.

-   Another piece of advice is to leverage packages and built-in color schemes in programming languages.

    -   We will talk about this a bit more in a future workshop.

## General Principles

1)  Make sure a plot is needed!

2)  Keep things simple.

3)  Be clear about your scale and axes.

## Additional References

1)  *OpenIntro Statistics* by Diez, etinkaya-Rundel, and Barr (https://www.openintro.org/book/os/)

    -   Free and high-quality PDF available online, courtesy of the publishers!

\

2)  *Statistics*, 4th ed. by Freedman, Pisani, and Purves

# Thank You!
